class k{constructor(){this.subscribable=new X(this),this.subscribers=new Set}subscribe(e){return this.subscribers.add(e),()=>this.unsubscribe(e)}unsubscribe(e){this.subscribers.delete(e)}clear(){this.subscribers.clear()}notifySubscribers(e){return[...this.subscribers].map(t=>t(e))}}class X{constructor(e){this.dispatcher=e}subscribe(e){return this.dispatcher.subscribe(e)}unsubscribe(e){this.dispatcher.unsubscribe(e)}}class re extends k{dispatch(e){this.notifySubscribers(e)}}class G extends k{constructor(){super(...arguments),this.value=!1}raise(){this.value||(this.value=!0,this.notifySubscribers())}reset(){this.value=!1}isRaised(){return this.value}subscribe(e){const t=super.subscribe(e);return this.value&&e(),t}}class A extends k{get current(){return this.value}set current(e){this.value=e,this.notifySubscribers(e)}constructor(e){super(),this.value=e,this.subscribable=new D(this)}subscribe(e,t=!0){const i=super.subscribe(e);return t&&e(this.value),i}}class D extends X{get current(){return this.dispatcher.current}subscribe(e,t=!0){return this.dispatcher.subscribe(e,t)}}class Y extends Error{constructor(e,t){typeof e=="string"?(super(e),this.remarks=t):(super(e.message),this.remarks=e.remarks,this.object=e.object,this.durationMs=e.durationMs,this.inspect=e.inspect)}}class ae{constructor(){this.resolveCurrent=null,this.current=null}async acquire(){for(;this.current;)await this.current;this.current=new Promise(e=>{this.resolveCurrent=e})}release(){var e;this.current=null,(e=this.resolveCurrent)==null||e.call(this),this.resolveCurrent=null}}const m=[];function Q(){const s=m.at(-1);if(!s)throw new Error("The scene is not available in the current context.");return s}function ue(s){m.push(s)}function he(s){if(m.pop()!==s)throw new Error("startScene/endScene were called out of order.")}function C(){var s;return((s=m.at(-1))==null?void 0:s.logger)??console}const M=[];function P(){const s=M.at(-1);if(!s)throw new Y("The thread is not available in the current context.",`<p><code>useThread()</code> can only be called from within generator functions.
      It&#39;s not available during rendering.</p>
`);return s}function le(s){M.push(s)}function ce(s){if(M.pop()!==s)throw new Error("startThread/endThread was called out of order.")}function U(s){return{message:s.message,stack:s.stack,remarks:s.remarks}}const W=180/Math.PI,S=Math.PI/180;function J(s){const e=Q(),t=P();return e.timeEvents.register(s,t.time())}const L=[];function K(){const s=L.at(-1);if(!s)throw new Error("The playback is not available in the current context.");return s}function oe(s){L.push(s)}function fe(s){if(L.pop()!==s)throw new Error("startPlayback/endPlayback were called out of order.")}function T(s,...e){const t={[s.name]:s},i=Object.getOwnPropertyDescriptor(t,s.name);if(i)for(let r=e.length-1;r>=0;r--)e[r](t,s.name,i)}function E(s){return function(e,t,i){i.value.prototype.name=s??t,i.value.prototype.threadable=!0}}function O(s,e){const t=Object.getPrototypeOf(s);t.threadable||(t.threadable=!0,t.name=typeof e=="string"?e:Z(e))}function Z(s){return Object.getPrototypeOf(s).name??null}var x;(function(s){s[s.Playing=0]="Playing",s[s.Rendering=1]="Rendering",s[s.Paused=2]="Paused",s[s.Presenting=3]="Presenting"})(x||(x={}));class de{constructor(){this.frame=0,this.speed=1,this.fps=30,this.duration=0,this.finished=!1,this.slides=[],this.previousScene=null,this.state=x.Paused,this.currentSceneReference=null,this.scenes=new A([])}get onSceneChanged(){if(this.currentSceneReference===null)throw new Error("PlaybackManager has not been properly initialized");return this.currentSceneReference.subscribable}get onScenesRecalculated(){return this.scenes.subscribable}get currentScene(){if(this.currentSceneReference===null)throw new Error("PlaybackManager has not been properly initialized");return this.currentSceneReference.current}set currentScene(e){if(!e)throw new Error("Invalid scene.");this.currentSceneReference??(this.currentSceneReference=new A(e)),this.currentSceneReference.current=e}setup(e){this.scenes.current=e,this.currentScene=e[0]}async progress(){return this.finished=await this.next(),this.finished}async seek(e){if(e<=this.frame||this.currentScene.isCached()&&this.currentScene.lastFrame<e){const t=this.findBestScene(e);t!==this.currentScene?(this.previousScene=null,this.currentScene=t,this.frame=this.currentScene.firstFrame,await this.currentScene.reset()):this.frame>=e&&(this.previousScene=null,this.frame=this.currentScene.firstFrame,await this.currentScene.reset())}for(this.finished=!1;this.frame<e&&!this.finished;)this.finished=await this.next();return this.finished}async goBack(){let e=this.currentScene.slides.getCurrent();if(e&&this.currentScene.slides.isWaiting()){const t=this.slides.indexOf(e);e=this.slides[t-1]}await this.seekSlide(e)}async goForward(){const e=this.currentScene.slides.getCurrent(),t=this.slides.indexOf(e);await this.seekSlide(this.slides[t+1])}async goTo(e){await this.seekSlide(this.slides.find(t=>t.id===e))}async seekSlide(e=null){if(!e)return;const{id:t,scene:i}=e;for((this.currentScene!==i||this.currentScene.slides.didHappen(t))&&(this.previousScene=null,this.currentScene=i,this.frame=this.currentScene.firstFrame,this.currentScene.slides.setTarget(t),await this.currentScene.reset()),this.finished=!1,this.currentScene.slides.setTarget(t);!this.currentScene.slides.isWaitingFor(t)&&!this.finished;)this.finished=await this.next();return this.currentScene.slides.setTarget(null),this.finished}async reset(){this.previousScene=null,this.currentScene=this.scenes.current[0],this.frame=0,await this.currentScene.reset()}reload(e){this.scenes.current.forEach(t=>t.reload(e))}async recalculate(){this.previousScene=null,this.slides=[];const e=this.speed;this.frame=0,this.speed=1;const t=[];try{for(const i of this.scenes.current)await i.recalculate(r=>{this.frame=r}),this.slides.push(...i.slides.onChanged.current),t.push(i)}finally{this.speed=e}this.scenes.current=t,this.duration=this.frame}async next(){if(this.previousScene&&(await this.previousScene.next(),this.currentScene.isFinished()&&(this.previousScene=null)),this.frame+=this.speed,this.currentScene.isFinished())return!0;if(await this.currentScene.next(),this.previousScene&&this.currentScene.isAfterTransitionIn()&&(this.previousScene=null),this.currentScene.canTransitionOut()){this.previousScene=this.currentScene;const e=this.getNextScene(this.previousScene);e&&(this.currentScene=e,await this.currentScene.reset(this.previousScene)),(!e||this.currentScene.isAfterTransitionIn())&&(this.previousScene=null)}return this.currentScene.isFinished()}findBestScene(e){let t=this.scenes.current[0];for(const i of this.scenes.current){if(!i.isCached()||i.lastFrame>e)return i;t=i}return t}getNextScene(e){const t=this.scenes.current;if(!e)return t[0];const i=t.findIndex(r=>r===e);return i<0?null:t[i+1]??null}}function V(s,e,t){if(e.length>=s.length){const i=Math.floor(e.length*t),r=Math.floor(v(s.length-1,e.length,t));let a="";for(let u=0;u<e.length;u++)u<i?a+=e[u]:(s[u]||u<=r)&&(a+=s[u]??e[u]);return a}else{const i=Math.round(s.length*(1-t)),r=Math.floor(v(s.length+1,e.length,t)),a=[];for(let u=s.length-1;u>=0;u--)u<i?a.unshift(s[u]):(e[u]||u<r)&&a.unshift(e[u]??s[u]);return a.join("")}}function j(s,e,t,i=!1){if(t===0)return s;if(t===1)return e;if(s==null||e==null){i||C().warn(`Attempting to lerp ${s} -> ${e} may result in unexpected behavior.`);return}if(typeof s=="number"&&typeof e=="number")return v(s,e,t);if(typeof s=="string"&&typeof e=="string")return V(s,e,t);if(typeof s=="boolean"&&typeof e=="boolean")return t<.5?s:e;if("lerp"in s)return s.lerp(e,t);if(s&&e&&typeof s=="object"&&typeof e=="object")if(Array.isArray(s)&&Array.isArray(e)){if(s.length===e.length)return s.map((r,a)=>j(r,e[a],t))}else{let r=!1;if(!(s instanceof Map)&&!(e instanceof Map)&&(r=!0,s=new Map(Object.entries(s)),e=new Map(Object.entries(e))),s instanceof Map&&e instanceof Map){const a=new Map;for(const u of new Set([...s.keys(),...e.keys()])){const h=j(s.get(u),e.get(u),t,!0);h!==void 0&&a.set(u,h)}return r?Object.fromEntries(a):a}}return e}function ve(s,e,t){return t<.5?s:e}function v(s,e,t){return s+(e-s)*t}function we(s,e,t,i,r){return t+(r-s)*(i-t)/(e-s)}function F(s,e,t){return t<s?s:t>e?e:t}function _(s,e,t){let i=e;t>1?t=1/t:i=!i;const r=i?Math.acos(F(-1,1,1-s)):Math.asin(s),a=v(r,v(0,Math.PI/2,s),t);let u=Math.sin(a),h=1-Math.cos(a);return e&&([u,h]=[h,u]),new n(u,h)}function ee(s,e=0,t=1){return s=s<.5?4*s*s*s:1-Math.pow(-2*s+2,3)/2,v(e,t,s)}function pe(s,e=0,t=1){return s=s===1?1:1-Math.pow(2,-10*s),v(e,t,s)}function ye(s,e=0,t=1){return v(e,t,s)}T(H,E());function*H(s,e,t){const i=P(),r=i.time(),a=i.time()+s;for(e(0,0);a>i.fixed;){const u=i.fixed-r,h=u/s;u>0&&e(h,u),yield}i.time(a),e(1,s),t==null||t(1,s)}T(te,E());function*te(s,e){yield*R(J(s)),e&&(yield*e)}T(R,E());function*R(s=0,e){const t=P(),i=K().framesToSeconds(1),r=t.time()+s;for(;r-i>t.fixed;)yield;t.time(r),e&&(yield*e)}function z(s,e){let t;return typeof s=="string"?(t=e(),O(t,s)):(t=s(),O(t,t)),t}class d{static collectPromise(e,t=null){const i={promise:e,value:t,stack:new Error().stack},r=this.collectionStack.at(-1);return r&&(i.owner=r.owner),e.then(a=>{i.value=a,r==null||r.markDirty()}),this.promises.push(i),i}static hasPromises(){return this.promises.length>0}static async consumePromises(){const e=[...this.promises];return await Promise.all(e.map(t=>t.promise)),this.promises=this.promises.filter(t=>!e.includes(t)),e}constructor(e){this.owner=e,this.dependencies=new Set,this.event=new G,this.markDirty=()=>this.event.raise(),this.invokable=this.invoke.bind(this),Object.defineProperty(this.invokable,"context",{value:this}),Object.defineProperty(this.invokable,"toPromise",{value:this.toPromise.bind(this)})}invoke(){}startCollecting(){if(d.collectionSet.has(this))throw new Y("A circular dependency occurred between signals.",`This can happen when signals reference each other in a loop.
        Try using the attached stack trace to locate said loop.`);d.collectionSet.add(this),d.collectionStack.push(this)}finishCollecting(){if(d.collectionSet.delete(this),d.collectionStack.pop()!==this)throw new Error("collectStart/collectEnd was called out of order.")}clearDependencies(){this.dependencies.forEach(e=>e.unsubscribe(this.markDirty)),this.dependencies.clear()}collect(){const e=d.collectionStack.at(-1);e&&(e.dependencies.add(this.event.subscribable),this.event.subscribe(e.markDirty))}dispose(){this.clearDependencies(),this.event.clear(),this.owner=null}async toPromise(){do await d.consumePromises(),this.invokable();while(d.hasPromises());return this.invokable}}d.collectionSet=new Set;d.collectionStack=[];d.promises=[];const I=Symbol.for("@motion-canvas/core/signals/default");function y(s){return typeof s=="function"}function se(s,e){return y(s)?()=>e(s()):e(s)}function ie(s){return y(s)?s():s}class B extends d{constructor(e,t,i=void 0,r=u=>u,a={}){super(i),this.initial=e,this.interpolation=t,this.parser=r,this.tweening=!1,Object.defineProperty(this.invokable,"reset",{value:this.reset.bind(this)}),Object.defineProperty(this.invokable,"save",{value:this.save.bind(this)}),Object.defineProperty(this.invokable,"isInitial",{value:this.isInitial.bind(this)}),this.initial!==void 0&&(this.current=this.initial,this.markDirty(),y(this.initial)||(this.last=this.parse(this.initial))),this.extensions={getter:this.getter.bind(this),setter:this.setter.bind(this),tweener:this.tweener.bind(this),...a}}toSignal(){return this.invokable}parse(e){return this.parser(e)}set(e){return this.extensions.setter(e),this.owner}setter(e){return e===I&&(e=this.initial),this.current===e?this.owner:(this.current=e,this.markDirty(),this.clearDependencies(),y(e)||(this.last=this.parse(e)),this.owner)}get(){return this.extensions.getter()}getter(){var e;if(this.event.isRaised()&&y(this.current)){this.clearDependencies(),this.startCollecting();try{this.last=this.parse(this.current())}catch(t){C().error({...U(t),inspect:(e=this.owner)==null?void 0:e.key})}this.finishCollecting()}return this.event.reset(),this.collect(),this.last}invoke(e,t,i=ee,r=this.interpolation){return e===void 0?this.get():t===void 0?this.set(e):this.createQueue(i,r).to(e,t)}createQueue(e,t){const i=this.get(),r=[],a=z("animation chain",function*(){for(;r.length>0;)yield*r.shift()});return a.to=(u,h,f=e,c=t)=>(e=f,t=c,r.push(this.tween(u,h,f,c)),a),a.back=(u,h=e,f=t)=>(e=h,t=f,r.push(this.tween(i,u,e,t)),a),a.wait=u=>(r.push(R(u)),a),a.run=u=>(r.push(u),a),a.do=u=>(r.push(z(function*(){u()})),a),a}*tween(e,t,i,r){e===I&&(e=this.initial),this.tweening=!0,yield*this.extensions.tweener(e,t,i,r),this.set(e),this.tweening=!1}*tweener(e,t,i,r){const a=this.get();yield*H(t,u=>{this.set(r(a,this.parse(ie(e)),i(u)))})}dispose(){super.dispose(),this.initial=void 0,this.current=void 0,this.last=void 0}reset(){return this.initial!==void 0&&this.set(this.initial),this.owner}save(){return this.set(this.get())}isInitial(){return this.collect(),this.current===this.initial}getInitial(){return this.initial}raw(){return this.current}isTweening(){return this.tweening}}class ne extends B{constructor(e,t,i,r,a=void 0,u={}){var h;super(void 0,r,a,t,u),this.entries=e,this.signals=[],this.parser=t;for(const f of e){let c,o;Array.isArray(f)?([c,o]=f,(h=o.context).owner??(h.owner=this)):(c=f,o=new B(se(i,p=>t(p)[f]),v,a??this.invokable).toSignal()),this.signals.push([c,o]),Object.defineProperty(this.invokable,c,{value:o})}}toSignal(){return this.invokable}parse(e){return this.parser(e)}getter(){return this.parse(Object.fromEntries(this.signals.map(([e,t])=>[e,t()])))}setter(e){if(y(e))for(const[t,i]of this.signals)i(()=>this.parser(e())[t]);else{const t=this.parse(e);for(const[i,r]of this.signals)r(t[i])}return this.owner}reset(){for(const[,e]of this.signals)e.reset();return this.owner}save(){for(const[,e]of this.signals)e.save();return this.owner}isInitial(){for(const[,e]of this.signals)if(!e.isInitial())return!1;return!0}raw(){return Object.fromEntries(this.signals.map(([e,t])=>[e,t.context.raw()]))}}const $=1e-6;class l{static fromRotation(e){return l.identity.rotate(e)}static fromTranslation(e){return l.identity.translate(new n(e))}static fromScaling(e){return l.identity.scale(new n(e))}get x(){return new n(this.values[0],this.values[1])}get y(){return new n(this.values[2],this.values[3])}get scaleX(){return this.values[0]}set scaleX(e){this.values[0]=this.x.normalized.scale(e).x}get skewX(){return this.values[1]}set skewX(e){this.values[1]=e}get scaleY(){return this.values[3]}set scaleY(e){this.values[3]=this.y.normalized.scale(e).y}get skewY(){return this.values[2]}set skewY(e){this.values[2]=e}get translateX(){return this.values[4]}set translateX(e){this.values[4]=e}get translateY(){return this.values[5]}set translateY(e){this.values[5]=e}get rotation(){return n.degrees(this.values[0],this.values[1])}set rotation(e){const t=this.rotate(e-this.rotation);this.values[0]=t.values[0],this.values[1]=t.values[1],this.values[2]=t.values[2],this.values[3]=t.values[3]}get translation(){return new n(this.values[4],this.values[5])}set translation(e){const t=new n(e);this.values[4]=t.x,this.values[5]=t.y}get scaling(){return new n(this.values[0],this.values[3])}set scaling(e){const t=new n(e),i=new n(this.values[0],this.values[1]).normalized,r=new n(this.values[2],this.values[3]).normalized;this.values[0]=i.x*t.x,this.values[1]=i.y*t.y,this.values[2]=r.x*t.x,this.values[3]=r.y*t.y}get inverse(){const e=this.values[0],t=this.values[1],i=this.values[2],r=this.values[3],a=this.values[4],u=this.values[5];let h=e*r-t*i;return h?(h=1/h,new l(r*h,-t*h,-i*h,e*h,(i*u-r*a)*h,(t*a-e*u)*h)):null}get determinant(){return this.values[0]*this.values[3]-this.values[1]*this.values[2]}get domMatrix(){return new DOMMatrix([this.values[0],this.values[1],this.values[2],this.values[3],this.values[4],this.values[5]])}constructor(e,t,i,r,a,u){if(this.values=new Float32Array(6),arguments.length===0){this.values=new Float32Array([1,0,0,1,0,0]);return}if(arguments.length===6){this.values[0]=e,this.values[1]=t,this.values[2]=i,this.values[3]=r,this.values[4]=a,this.values[5]=u;return}if(e instanceof DOMMatrix){this.values[0]=e.m11,this.values[1]=e.m12,this.values[2]=e.m21,this.values[3]=e.m22,this.values[4]=e.m41,this.values[5]=e.m42;return}if(e instanceof l){this.values=e.values;return}if(Array.isArray(e)){if(e.length===2){this.values[0]=e[0],this.values[1]=e[1],this.values[2]=t[0],this.values[3]=t[1],this.values[4]=i[0],this.values[5]=i[1];return}if(e.length===3){const o=new n(e[0]),p=new n(e[1]),b=new n(e[2]);this.values[0]=o.x,this.values[1]=o.y,this.values[2]=p.x,this.values[3]=p.y,this.values[4]=b.x,this.values[5]=b.y;return}this.values[0]=e[0],this.values[1]=e[1],this.values[2]=e[2],this.values[3]=e[3],this.values[4]=e[4],this.values[5]=e[5];return}const h=new n(e),f=new n(t),c=new n(i);this.values[0]=h.x,this.values[1]=h.y,this.values[2]=f.x,this.values[3]=f.y,this.values[4]=c.x,this.values[5]=c.y}column(e){return new n(this.values[e*2],this.values[e*2+1])}row(e){return[this.values[e],this.values[e+2],this.values[e+4]]}mul(e){const t=this.values[0],i=this.values[1],r=this.values[2],a=this.values[3],u=this.values[4],h=this.values[5],f=e.values[0],c=e.values[1],o=e.values[2],p=e.values[3],b=e.values[4],N=e.values[5];return new l(t*f+r*c,i*f+a*c,t*o+r*p,i*o+a*p,t*b+r*N+u,i*b+a*N+h)}rotate(e,t=!0){t&&(e*=S);const i=this.values[0],r=this.values[1],a=this.values[2],u=this.values[3],h=this.values[4],f=this.values[5],c=Math.sin(e),o=Math.cos(e);return new l(i*o+a*c,r*o+u*c,i*-c+a*o,r*-c+u*o,h,f)}scale(e){const t=new n(e);return new l(this.values[0]*t.x,this.values[1]*t.x,this.values[2]*t.y,this.values[3]*t.y,this.values[4],this.values[5])}mulScalar(e){return new l(this.values[0]*e,this.values[1]*e,this.values[2]*e,this.values[3]*e,this.values[4]*e,this.values[5]*e)}translate(e){const t=new n(e);return new l(this.values[0],this.values[1],this.values[2],this.values[3],this.values[0]*t.x+this.values[2]*t.y+this.values[4],this.values[1]*t.x+this.values[3]*t.y+this.values[5])}add(e){return new l(this.values[0]+e.values[0],this.values[1]+e.values[1],this.values[2]+e.values[2],this.values[3]+e.values[3],this.values[4]+e.values[4],this.values[5]+e.values[5])}sub(e){return new l(this.values[0]-e.values[0],this.values[1]-e.values[1],this.values[2]-e.values[2],this.values[3]-e.values[3],this.values[4]-e.values[4],this.values[5]-e.values[5])}toSymbol(){return l.symbol}equals(e,t=$){return Math.abs(this.values[0]-e.values[0])<=t+Number.EPSILON&&Math.abs(this.values[1]-e.values[1])<=t+Number.EPSILON&&Math.abs(this.values[2]-e.values[2])<=t+Number.EPSILON&&Math.abs(this.values[3]-e.values[3])<=t+Number.EPSILON&&Math.abs(this.values[4]-e.values[4])<=t+Number.EPSILON&&Math.abs(this.values[5]-e.values[5])<=t+Number.EPSILON}exactlyEquals(e){return this.values[0]===e.values[0]&&this.values[1]===e.values[1]&&this.values[2]===e.values[2]&&this.values[3]===e.values[3]&&this.values[4]===e.values[4]&&this.values[5]===e.values[5]}}l.symbol=Symbol.for("@motion-canvas/core/types/Matrix2D");l.identity=new l(1,0,0,1,0,0);l.zero=new l(0,0,0,0,0,0);var q;(function(s){s[s.Vertical=1]="Vertical",s[s.Horizontal=2]="Horizontal"})(q||(q={}));var w;(function(s){s[s.Top=4]="Top",s[s.Bottom=8]="Bottom",s[s.Left=16]="Left",s[s.Right=32]="Right"})(w||(w={}));var g;(function(s){s[s.Middle=3]="Middle",s[s.Top=5]="Top",s[s.Bottom=9]="Bottom",s[s.Left=18]="Left",s[s.Right=34]="Right",s[s.TopLeft=20]="TopLeft",s[s.TopRight=36]="TopRight",s[s.BottomLeft=24]="BottomLeft",s[s.BottomRight=40]="BottomRight"})(g||(g={}));function be(s){if(s===g.Middle)return n.zero;let e=0;s&w.Left?e=-1:s&w.Right&&(e=1);let t=0;return s&w.Top?t=-1:s&w.Bottom&&(t=1),new n(e,t)}class n{static createSignal(e,t=n.lerp,i){return new ne(["x","y"],r=>new n(r),e,t,i).toSignal()}static lerp(e,t,i){let r,a;return typeof i=="number"?r=a=i:(r=i.x,a=i.y),new n(v(e.x,t.x,r),v(e.y,t.y,a))}static arcLerp(e,t,i,r=!1,a){return a??(a=e.sub(t).ctg),n.lerp(e,t,_(i,r,a))}static createArcLerp(e,t){return(i,r,a)=>n.arcLerp(i,r,a,e,t)}static polarLerp(e,t,i,r=!1,a=n.zero){e=e.sub(a),t=t.sub(a);const u=e.degrees;let h=t.degrees;u>h!==r&&(h=h+(r?-360:360));const c=v(u,h,i)*S,o=v(e.magnitude,t.magnitude,i);return new n(o*Math.cos(c)+a.x,o*Math.sin(c)+a.y)}static createPolarLerp(e=!1,t=n.zero){return(i,r,a)=>n.polarLerp(i,r,a,e,new n(t))}static fromOrigin(e){const t=new n;return e===g.Middle||(e&w.Left?t.x=-1:e&w.Right&&(t.x=1),e&w.Top?t.y=-1:e&w.Bottom&&(t.y=1)),t}static fromScalar(e){return new n(e,e)}static fromRadians(e){return new n(Math.cos(e),Math.sin(e))}static fromDegrees(e){return n.fromRadians(e*S)}static radians(e,t){return Math.atan2(t,e)}static degrees(e,t){return n.radians(e,t)*W}static magnitude(e,t){return Math.sqrt(e*e+t*t)}static squaredMagnitude(e,t){return e*e+t*t}static angleBetween(e,t){return Math.acos(F(-1,1,e.dot(t)/(e.magnitude*t.magnitude)))*(e.cross(t)>=0?1:-1)}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}get magnitude(){return n.magnitude(this.x,this.y)}get squaredMagnitude(){return n.squaredMagnitude(this.x,this.y)}get normalized(){return this.scale(1/n.magnitude(this.x,this.y))}get safe(){return new n(isNaN(this.x)?0:this.x,isNaN(this.y)?0:this.y)}get flipped(){return new n(-this.x,-this.y)}get floored(){return new n(Math.floor(this.x),Math.floor(this.y))}get perpendicular(){return new n(this.y,-this.x)}get radians(){return n.radians(this.x,this.y)}get degrees(){return n.degrees(this.x,this.y)}get ctg(){return this.x/this.y}constructor(e,t){if(this.x=0,this.y=0,e!=null){if(typeof e!="object"){this.x=e,this.y=t??e;return}if(Array.isArray(e)){this.x=e[0],this.y=e[1];return}if("width"in e){this.x=e.width,this.y=e.height;return}this.x=e.x,this.y=e.y}}lerp(e,t){return n.lerp(this,e,t)}getOriginOffset(e){const t=n.fromOrigin(e);return t.x*=this.x/2,t.y*=this.y/2,t}scale(e){return new n(this.x*e,this.y*e)}transformAsPoint(e){const t=new l(e);return new n(this.x*t.scaleX+this.y*t.skewY+t.translateX,this.x*t.skewX+this.y*t.scaleY+t.translateY)}transform(e){const t=new l(e);return new n(this.x*t.scaleX+this.y*t.skewY,this.x*t.skewX+this.y*t.scaleY)}mul(e){const t=new n(e);return new n(this.x*t.x,this.y*t.y)}div(e){const t=new n(e);return new n(this.x/t.x,this.y/t.y)}add(e){const t=new n(e);return new n(this.x+t.x,this.y+t.y)}sub(e){const t=new n(e);return new n(this.x-t.x,this.y-t.y)}dot(e){const t=new n(e);return this.x*t.x+this.y*t.y}cross(e){const t=new n(e);return this.x*t.y-this.y*t.x}mod(e){const t=new n(e);return new n(this.x%t.x,this.y%t.y)}rotate(e,t=n.zero){const i=new n(t),r=l.fromTranslation(i).rotate(e).translate(i.flipped);return this.transformAsPoint(r)}addX(e){return new n(this.x+e,this.y)}addY(e){return new n(this.x,this.y+e)}toSymbol(){return n.symbol}toString(){return`Vector2(${this.x}, ${this.y})`}serialize(){return{x:this.x,y:this.y}}exactlyEquals(e){return this.x===e.x&&this.y===e.y}equals(e,t=$){return Math.abs(this.x-e.x)<=t+Number.EPSILON&&Math.abs(this.y-e.y)<=t+Number.EPSILON}}n.symbol=Symbol.for("@motion-canvas/core/types/Vector2");n.zero=new n;n.one=new n(1,1);n.right=new n(1,0);n.left=new n(-1,0);n.up=new n(0,1);n.down=new n(0,-1);n.top=new n(0,-1);n.bottom=new n(0,1);n.topLeft=new n(-1,-1);n.topRight=new n(1,-1);n.bottomLeft=new n(-1,1);n.bottomRight=new n(1,1);export{se as A,ee as B,ne as C,d as D,k as E,Q as F,y as G,H,be as I,ve as J,pe as K,ye as L,l as M,we as N,g as O,de as P,ae as S,A as V,re as a,n as b,x as c,F as d,ie as e,T as f,Y as g,S as h,ce as i,O as j,P as k,K as l,v as m,ue as n,oe as o,fe as p,he as q,U as r,le as s,E as t,C as u,B as v,R as w,j as x,_ as y,$ as z};
